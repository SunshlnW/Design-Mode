# Facade门面模式

## 接口隔离模式

1. 在组建构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层**间接**（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。
2. 典型模式
    * Facade
    * Proxy
    * Adapter
    * Mediator

## 系统间耦合的复杂度

![20200102171846.png](https://raw.githubusercontent.com/SunshlnW/Design-Mode/master/image/Facade%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/20200102171846.png)

## 动机（Motivation）

1. 上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。
2. 如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？

## 模式定义

为子系统中的一组接口提供一个**一致（稳定）**的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（**复用**）。
                                                ---《设计模式》GoF

## 结构（Structure）

![20200102172510.png](https://raw.githubusercontent.com/SunshlnW/Design-Mode/master/image/Facade%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/20200102172510.png)

## 要点总结

1. 从客户程序的角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“**解耦**”的效果---内部子系统的任何变化不会影响到Facade接口的变化。
2. Facade设计模式更注重从**架构**的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。
3. Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是“**相互耦合关系比较大**的一系列组件”，而不是一个简单的功能集合。
4. Facade对外是松耦合，内部是高内聚。
