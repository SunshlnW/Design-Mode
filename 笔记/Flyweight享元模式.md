# Flyweight享元模式

## “对象性能”模式

1. 面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不记。但是某些情况，面向对象所带来的成本必须谨慎处理。
2. 典型模式
    * Singleton
    * Flyweight

## 动机（Motivation）

1. 在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时待见---主要指内存需求方面的代价。
2. 如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？

## 模式定义

运用**共享**技术有效地支持**大量**细粒度的对象。
                                                ---《设计模式》GoF

## 结构（Structure）

![20200101222330.png](https://raw.githubusercontent.com/SunshlnW/Design-Mode/master/image/Flyweight%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/20200101222330.png)

## 要点总结

1. 面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。
2. Flyweight采用**对象共享**的做法来**降低系统中对象的个数**，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意**对象状态**的处理。（因为多个对象要共享，所以一般对象状态都是只读的）
3. 对象的数量太大从而导致对象内存开销加大---什么样的数量才算大？这需要我们仔细的根据具体应用情况来进行评估，而不能凭空臆断。
